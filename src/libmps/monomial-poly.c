#include <mps/mps.h>
#include <string.h>
#include <assert.h>

/**
 * @brief Return a newly allocated mps_monomial_poly of the given degree.
 */
mps_monomial_poly *
mps_monomial_poly_new (mps_status * s, long int degree)
{
  int i;
  mps_monomial_poly  * mp = mps_malloc (sizeof (mps_monomial_poly));
  
  /* Set the degree of the polynomial */
  mp->n = degree;

  /* Allocate the space for the coefficients of the polynomial, all
  * the floating point versions. */
  mp->spar = mps_boolean_valloc (degree + 2);
  mp->fpc  = cplx_valloc (degree + 1);
  mp->fpr  = double_valloc (degree + 1);
  mp->dpr  = rdpe_valloc (degree + 1);
  mp->dpc  = cdpe_valloc (degree + 1);
  mp->mfpc = mpc_valloc (degree + 1);
  mp->mfpr = mpf_valloc (degree + 1);

  mpf_vinit2 (mp->mfpr, degree + 1, s->mpwp);
  mpc_vinit2 (mp->mfpc, degree + 1, s->mpwp);

  /* Allocate space for the moduli of the coefficients */
  mp->fap = double_valloc (degree + 1);
  mp->dap = rdpe_valloc (degree + 1);

  /* Allocate space for the coefficients of the derivative */
  mp->fppc = cplx_valloc (degree);
  mp->mfppc = mpc_valloc (degree + 1);
  mpc_vinit2 (mp->mfppc, degree + 1, s->mpwp);

  /* Allocate space for the coefficients initially parsed as
   * exact */
  mp->initial_mqp_r = mpq_valloc (degree + 1);
  mp->initial_mqp_i = mpq_valloc (degree + 1);

  mpq_vinit (mp->initial_mqp_r, degree + 1);
  mpq_vinit (mp->initial_mqp_i, degree + 1);

  pthread_mutex_init (&mp->regenerating, NULL);

  mp->mfpc_mutex = mps_newv (pthread_mutex_t, degree + 1);
  for (i = 0; i <= degree; i++)
    pthread_mutex_init (&mp->mfpc_mutex[i], NULL);

  memset (mp->spar, 0, sizeof (mps_boolean) * (degree + 1));
  memset (mp->fap, 0, sizeof (double) * (degree + 1));
  
  for (i = 0; i <= degree; i++)
    rdpe_set (mp->dap[i], rdpe_zero);

  mp->structure = MPS_STRUCTURE_UNKNOWN;
  mp->prec = s->mpwp;

  return mp;
}

/**
 * @brief Free a instance of <code>mps_monomial_poly</code> previously
 * allocated with <code>mps_monomial_poly_new()</code>.
 */
void
mps_monomial_poly_free (mps_status * s, mps_monomial_poly * mp)
{
  mps_boolean_vfree (mp->spar);
  double_vfree (mp->fpr);
  cplx_vfree (mp->fpc);
  rdpe_vfree (mp->dpr);
  cdpe_vfree (mp->dpc);

  double_vfree (mp->fap);
  rdpe_vfree (mp->dap);

  mpf_vclear (mp->mfpr, mp->n + 1);
  mpc_vclear (mp->mfpc, mp->n + 1);

  mpf_vfree (mp->mfpr);
  mpc_vfree (mp->mfpc);

  mpq_vclear (mp->initial_mqp_r, mp->n + 1);
  mpq_vclear (mp->initial_mqp_i, mp->n + 1);

  mpq_vfree (mp->initial_mqp_r);
  mpq_vfree (mp->initial_mqp_i);

  cplx_vfree (mp->fppc);
  mpc_vclear (mp->mfppc, mp->n + 1);
  mpc_vfree (mp->mfppc);

  free (mp->mfpc_mutex);

  free (mp);
}

/**
 * @brief Raise the precision bits of the multiprecision fields of the 
 * polynomial to selected value.
 *
 * If the polynomial coefficients were generated by integer or rational
 * input they will be autoregenerated. 
 *
 * @param s  The status of the computation.
 * @param mp The polynomial that need the precision raised.
 * @param prec The selected bits of precision.
 */
void
mps_monomial_poly_raise_precision (mps_status * s, mps_monomial_poly * mp, long int prec)
{
  int k;

  pthread_mutex_lock (&mp->regenerating);

  if (prec <= mpc_get_prec (mp->mfpc[s->n]))
    {
      pthread_mutex_unlock (&mp->regenerating);
      return;
    }

  /* raise the precision of  mfpc */
  if (!MPS_INPUT_CONFIG_IS_USER (s->input_config))
    for (k = 0; k < mp->n + 1; k++)
      {
	pthread_mutex_lock (&mp->mfpc_mutex[k]); 
	mpc_set_prec (mp->mfpc[k], prec);
	pthread_mutex_unlock (&mp->mfpc_mutex[k]); 
      }

  /* Raise the precision of p' */
  if (MPS_INPUT_CONFIG_IS_SPARSE (s->input_config))
    for (k = 0; k < s->n; k++)
      if (mp->spar[k + 1])
        {
          mpc_set_prec (mp->mfppc[k], prec);
          mpc_mul_ui (mp->mfppc[k], mp->mfpc[k + 1], k + 1);
        }

  if (MPS_INPUT_CONFIG_IS_INTEGER (s->input_config) 
      || MPS_INPUT_CONFIG_IS_RATIONAL (s->input_config))
    {
      for (k = 0; k <= s->n ; ++k)
	{
	  pthread_mutex_lock (&mp->mfpc_mutex[k]); 
	  mpf_set_q (mpc_Re (mp->mfpc[k]), mp->initial_mqp_r[k]);
	  mpf_set_q (mpc_Im (mp->mfpc[k]), mp->initial_mqp_i[k]);
	  pthread_mutex_unlock (&mp->mfpc_mutex[k]); 
	}
    }

  mp->prec = prec;
  pthread_mutex_unlock (&mp->regenerating);
}

/**
 * @brief This routine can be used to set the i-th coefficients of the 
 * polynomial with a multiprecision rational number. 
 *
 * @param s The mps_status the will be used for the computation. This shall be passed
 * along with the polynomial because it manages user interaction and can perform
 * error handling.
 *
 * @param mp The monomial_poly that will hold the coefficient.
 * @param i  The exponent of the monomial to which the coefficient is related.
 * @param real_part The real part of the coefficient.
 * @param imag_part The imaginary part of the coefficients.
 */
void
mps_monomial_poly_set_coefficient_q (mps_status * s, mps_monomial_poly * mp, long int i, 
				     mpq_t real_part, mpq_t imag_part)
{
  /* Updating data_type information */
  if (mp->structure == MPS_STRUCTURE_UNKNOWN)
    mp->structure = (mpq_sgn (imag_part) != 0) ? 
      MPS_STRUCTURE_COMPLEX_RATIONAL : MPS_STRUCTURE_REAL_RATIONAL;

  if (mp->structure == MPS_STRUCTURE_REAL_RATIONAL &&
      mpq_sgn (imag_part) != 0)
    mp->structure = MPS_STRUCTURE_COMPLEX_RATIONAL;

  assert (mp->structure == MPS_STRUCTURE_COMPLEX_RATIONAL ||
	  mp->structure == MPS_STRUCTURE_REAL_RATIONAL);

  /* Set the coefficients first */
  mpq_set (mp->initial_mqp_r[i], real_part);
  mpq_set (mp->initial_mqp_i[i], imag_part);

  /* Then update the other coefficients */
  mpf_set_q (mpc_Re (mp->mfpc[i]), real_part);
  mpf_set_q (mpc_Im (mp->mfpc[i]), imag_part);

  mpc_get_cdpe (mp->dpc[i], mp->mfpc[i]);
  mpc_get_cplx (mp->fpc[i], mp->mfpc[i]);

  if ((mpq_sgn (real_part) == 0) && (mpq_sgn (imag_part) == 0))
    mp->spar[i] = false;
  else 
    mp->spar[i] = true;

  if (mp->spar[i])
    {
      mpc_get_cplx (mp->fpc[i], mp->mfpc[i]);
      mpc_get_cdpe (mp->dpc[i], mp->mfpc[i]);

      /* Compute modules of coefficients */
      cdpe_mod (mp->dap[i], mp->dpc[i]);
      mp->fap[i] = rdpe_get_d (mp->dap[i]);
    }
  else
    {
      cplx_set (mp->fpc[i], cplx_zero);
      cdpe_set (mp->dpc[i], cdpe_zero);
	  
      rdpe_set (mp->dap[i], rdpe_zero);
      mp->fap[i] = 0.0f;
    }
}

/**
 * @brief Set the coefficient in position i of the mpnomial.
 *
 * @param s The <code>mps_status</code> associated to this computation.
 * @param mp The <code>monomial_poly</code> in which the coefficients will be set.
 * @param i The index of the coefficient to set.
 * @param real_part The real part of the coefficient.
 * @param imag_part The imaginary part of the coefficient.
 */
void
mps_monomial_poly_set_coefficient_d (mps_status * s, mps_monomial_poly * mp, long int i,
				     double real_part, double imag_part)
{
  /* Updating data structure information */
  if (mp->structure == MPS_STRUCTURE_UNKNOWN)
    mp->structure = (imag_part == 0) ?
      MPS_STRUCTURE_REAL_FP : MPS_STRUCTURE_COMPLEX_FP;

  if (imag_part != 0 && mp->structure == MPS_STRUCTURE_REAL_FP)
    mp->structure = MPS_STRUCTURE_COMPLEX_FP;

  assert (mp->structure == MPS_STRUCTURE_REAL_FP ||
	  mp->structure == MPS_STRUCTURE_COMPLEX_FP);

  /* Set the coefficients */
  mpf_set_d (mp->mfpr[i], real_part);
  mpc_set_d (mp->mfpc[i], real_part, imag_part);

  /* Update spar */
  mp->spar[i] = !((real_part == 0) && (imag_part == 0));

  if (mp->spar[i])
    {
      mpc_get_cplx (mp->fpc[i], mp->mfpc[i]);
      mpc_get_cdpe (mp->dpc[i], mp->mfpc[i]);

      /* Compute modules of coefficients */
      cdpe_mod (mp->dap[i], mp->dpc[i]);
      mp->fap[i] = rdpe_get_d (mp->dap[i]);
    }
  else
    {
      cplx_set (mp->fpc[i], cplx_zero);
      cdpe_set (mp->dpc[i], cdpe_zero);
	  
      rdpe_set (mp->dap[i], rdpe_zero);
      mp->fap[i] = 0.0f;
    }
}

void 
mps_monomial_poly_set_coefficient_int (mps_status * s, mps_monomial_poly * mp, long int i,
				       long long real_part, long long imag_part)
{
  /* Updating data_type information */
  if (mp->structure == MPS_STRUCTURE_UNKNOWN)
    mp->structure = (imag_part) != 0 ? 
      MPS_STRUCTURE_COMPLEX_INTEGER : MPS_STRUCTURE_REAL_INTEGER;

  if (mp->structure == MPS_STRUCTURE_REAL_INTEGER &&
      imag_part != 0)
    mp->structure = MPS_STRUCTURE_COMPLEX_INTEGER;

  assert (mp->structure == MPS_STRUCTURE_COMPLEX_INTEGER ||
	  mp->structure == MPS_STRUCTURE_REAL_INTEGER);

  
  /* Set the coefficients first */
  mpq_set_si (mp->initial_mqp_r[i], real_part, 1);
  mpq_set_si (mp->initial_mqp_i[i], imag_part, 1);

  /* Then update the other coefficients */
  mpf_set_q (mpc_Re (mp->mfpc[i]), mp->initial_mqp_r[i]);
  mpf_set_q (mpc_Im (mp->mfpc[i]), mp->initial_mqp_i[i]);

  mpc_get_cdpe (mp->dpc[i], mp->mfpc[i]);
  mpc_get_cplx (mp->fpc[i], mp->mfpc[i]);

  if ((real_part == 0) && (imag_part == 0))
    mp->spar[i] = false;
  else 
    mp->spar[i] = true;

  if (mp->spar[i])
    {
      mpc_get_cplx (mp->fpc[i], mp->mfpc[i]);
      mpc_get_cdpe (mp->dpc[i], mp->mfpc[i]);

      /* Compute modules of coefficients */
      cdpe_mod (mp->dap[i], mp->dpc[i]);
      mp->fap[i] = rdpe_get_d (mp->dap[i]);
    }
  else
    {
      cplx_set (mp->fpc[i], cplx_zero);
      cdpe_set (mp->dpc[i], cdpe_zero);
	  
      rdpe_set (mp->dap[i], rdpe_zero);
      mp->fap[i] = 0.0f;
    }
}
